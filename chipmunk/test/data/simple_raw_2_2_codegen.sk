// Generated at commit 36e207bb57de682506785c2981db801697bc3978

// This is an autogenerated sketch file corresponding to
// the router's data path and is used to solve the Chipmunk compilation problem.
// program_file = example_specs/simple.sk num_pipeline_stages = 2
// num_alus_per_stage = 2
// num_phv_containers = 2

int simple_raw_2_2_stateless_alu_0_0_mux1_ctrl= ??(1);
int simple_raw_2_2_stateless_alu_0_0_mux2_ctrl= ??(1);
int simple_raw_2_2_stateless_alu_0_0_opcode= ??(5);
int simple_raw_2_2_stateless_alu_0_0_immediate= ??(2);
int simple_raw_2_2_stateless_alu_0_1_mux1_ctrl= ??(1);
int simple_raw_2_2_stateless_alu_0_1_mux2_ctrl= ??(1);
int simple_raw_2_2_stateless_alu_0_1_opcode= ??(5);
int simple_raw_2_2_stateless_alu_0_1_immediate= ??(2);
int simple_raw_2_2_stateful_alu_0_0_Mux2_0_global= ??(1);
int simple_raw_2_2_stateful_alu_0_0_Opt_0_global= ??(1);
int simple_raw_2_2_stateful_alu_0_0_const_0_global= ??(2);
int simple_raw_2_2_stateless_alu_1_0_mux1_ctrl= ??(1);
int simple_raw_2_2_stateless_alu_1_0_mux2_ctrl= ??(1);
int simple_raw_2_2_stateless_alu_1_0_opcode= ??(5);
int simple_raw_2_2_stateless_alu_1_0_immediate= ??(2);
int simple_raw_2_2_stateless_alu_1_1_mux1_ctrl= ??(1);
int simple_raw_2_2_stateless_alu_1_1_mux2_ctrl= ??(1);
int simple_raw_2_2_stateless_alu_1_1_opcode= ??(5);
int simple_raw_2_2_stateless_alu_1_1_immediate= ??(2);
int simple_raw_2_2_stateful_alu_1_0_Mux2_0_global= ??(1);
int simple_raw_2_2_stateful_alu_1_0_Opt_0_global= ??(1);
int simple_raw_2_2_stateful_alu_1_0_const_0_global= ??(2);
int simple_raw_2_2_stateful_operand_mux_0_0_0_ctrl= ??(1);
int simple_raw_2_2_stateful_operand_mux_1_0_0_ctrl= ??(1);
int simple_raw_2_2_output_mux_phv_0_0_ctrl= ??(1);
int simple_raw_2_2_output_mux_phv_0_1_ctrl= ??(1);
int simple_raw_2_2_output_mux_phv_1_0_ctrl= ??(1);
int simple_raw_2_2_output_mux_phv_1_1_ctrl= ??(1);
int simple_raw_2_2_salu_config_0_0= ??(1);
int simple_raw_2_2_salu_config_1_0= ??(1);


// Definitions of muxes and ALUs of the router
// Operand muxes for each ALU in each stage
// Total of 2 * 2 * 3 2-to-1 muxes
// The 3 is for two stateless operands and one stateful operand.

int simple_raw_2_2_stateful_operand_mux_0_0_0(int input0,int input1, int simple_raw_2_2_stateful_operand_mux_0_0_0_ctrl_local) {

  int mux_ctrl = simple_raw_2_2_stateful_operand_mux_0_0_0_ctrl_local;
  if (mux_ctrl == 0) {
    return input0;
  }


  else { return input1; }

}
int simple_raw_2_2_stateful_operand_mux_1_0_0(int input0,int input1, int simple_raw_2_2_stateful_operand_mux_1_0_0_ctrl_local) {

  int mux_ctrl = simple_raw_2_2_stateful_operand_mux_1_0_0_ctrl_local;
  if (mux_ctrl == 0) {
    return input0;
  }


  else { return input1; }

}


// Output mux for each PHV container
// Allows the container to be written from either its own stateless ALU or any stateful ALU

int simple_raw_2_2_output_mux_phv_0_0(int input0,int input1, int simple_raw_2_2_output_mux_phv_0_0_ctrl_local) {

  int mux_ctrl = simple_raw_2_2_output_mux_phv_0_0_ctrl_local;
  if (mux_ctrl == 0) {
    return input0;
  }


  else { return input1; }

}
int simple_raw_2_2_output_mux_phv_0_1(int input0,int input1, int simple_raw_2_2_output_mux_phv_0_1_ctrl_local) {

  int mux_ctrl = simple_raw_2_2_output_mux_phv_0_1_ctrl_local;
  if (mux_ctrl == 0) {
    return input0;
  }


  else { return input1; }

}
int simple_raw_2_2_output_mux_phv_1_0(int input0,int input1, int simple_raw_2_2_output_mux_phv_1_0_ctrl_local) {

  int mux_ctrl = simple_raw_2_2_output_mux_phv_1_0_ctrl_local;
  if (mux_ctrl == 0) {
    return input0;
  }


  else { return input1; }

}
int simple_raw_2_2_output_mux_phv_1_1(int input0,int input1, int simple_raw_2_2_output_mux_phv_1_1_ctrl_local) {

  int mux_ctrl = simple_raw_2_2_output_mux_phv_1_1_ctrl_local;
  if (mux_ctrl == 0) {
    return input0;
  }


  else { return input1; }

}


// Definition for ALUs

int simple_raw_2_2_stateless_alu_0_0_mux1(int input0,int input1, int simple_raw_2_2_stateless_alu_0_0_mux1_ctrl_local) {

  int mux_ctrl = simple_raw_2_2_stateless_alu_0_0_mux1_ctrl_local;
  if (mux_ctrl == 0) {
    return input0;
  }


  else { return input1; }

}int simple_raw_2_2_stateless_alu_0_0_mux2(int input0,int input1, int simple_raw_2_2_stateless_alu_0_0_mux2_ctrl_local) {

  int mux_ctrl = simple_raw_2_2_stateless_alu_0_0_mux2_ctrl_local;
  if (mux_ctrl == 0) {
    return input0;
  }


  else { return input1; }

}int simple_raw_2_2_stateless_alu_0_0(int input0,int input1, int opcode_hole_local, int immediate_operand_hole_local, int mux1_ctrl_hole_local, int mux2_ctrl_hole_local) {
  int opcode = opcode_hole_local;
  int immediate_operand = immediate_operand_hole_local;

  int x = simple_raw_2_2_stateless_alu_0_0_mux1(input0,input1, mux1_ctrl_hole_local);
  int y = simple_raw_2_2_stateless_alu_0_0_mux2(input0,input1, mux2_ctrl_hole_local);

  if (opcode == 0) {
    return immediate_operand;
  } else if (opcode == 1) {
    return x + y;
  } else if (opcode == 2) {
    return x + immediate_operand;
  } else if (opcode == 3) {
    return x - y;
  } else if (opcode == 4) {
    return x - immediate_operand;
  } else if (opcode == 5) {
    return immediate_operand - x;
  } else if (opcode == 6) {
    return (x != 0) || (y != 0);
  } else if (opcode == 7) {
    return (x != 0) || (immediate_operand != 0);
  } else if (opcode == 8) {
    return (x != 0) && (y != 0);
  } else if (opcode == 9) {
    return (x != 0) && (immediate_operand != 0);
  } else if (opcode == 10) {
    return ! (x != 0);
  } else if (opcode == 11) {
    return x != y;
  } else if (opcode == 12) {
    return x != immediate_operand;
  } else if (opcode == 13) {
    return x == y;
  } else if (opcode == 14) {
    return x == immediate_operand;
  } else if (opcode == 15) {
    return x >= y;
  } else if (opcode == 16) {
    return x >= immediate_operand;
  } else if (opcode == 17) {
    return x < y;
  } else {
    return x < immediate_operand;
  }
}
int simple_raw_2_2_stateless_alu_0_1_mux1(int input0,int input1, int simple_raw_2_2_stateless_alu_0_1_mux1_ctrl_local) {

  int mux_ctrl = simple_raw_2_2_stateless_alu_0_1_mux1_ctrl_local;
  if (mux_ctrl == 0) {
    return input0;
  }


  else { return input1; }

}int simple_raw_2_2_stateless_alu_0_1_mux2(int input0,int input1, int simple_raw_2_2_stateless_alu_0_1_mux2_ctrl_local) {

  int mux_ctrl = simple_raw_2_2_stateless_alu_0_1_mux2_ctrl_local;
  if (mux_ctrl == 0) {
    return input0;
  }


  else { return input1; }

}int simple_raw_2_2_stateless_alu_0_1(int input0,int input1, int opcode_hole_local, int immediate_operand_hole_local, int mux1_ctrl_hole_local, int mux2_ctrl_hole_local) {
  int opcode = opcode_hole_local;
  int immediate_operand = immediate_operand_hole_local;

  int x = simple_raw_2_2_stateless_alu_0_1_mux1(input0,input1, mux1_ctrl_hole_local);
  int y = simple_raw_2_2_stateless_alu_0_1_mux2(input0,input1, mux2_ctrl_hole_local);

  if (opcode == 0) {
    return immediate_operand;
  } else if (opcode == 1) {
    return x + y;
  } else if (opcode == 2) {
    return x + immediate_operand;
  } else if (opcode == 3) {
    return x - y;
  } else if (opcode == 4) {
    return x - immediate_operand;
  } else if (opcode == 5) {
    return immediate_operand - x;
  } else if (opcode == 6) {
    return (x != 0) || (y != 0);
  } else if (opcode == 7) {
    return (x != 0) || (immediate_operand != 0);
  } else if (opcode == 8) {
    return (x != 0) && (y != 0);
  } else if (opcode == 9) {
    return (x != 0) && (immediate_operand != 0);
  } else if (opcode == 10) {
    return ! (x != 0);
  } else if (opcode == 11) {
    return x != y;
  } else if (opcode == 12) {
    return x != immediate_operand;
  } else if (opcode == 13) {
    return x == y;
  } else if (opcode == 14) {
    return x == immediate_operand;
  } else if (opcode == 15) {
    return x >= y;
  } else if (opcode == 16) {
    return x >= immediate_operand;
  } else if (opcode == 17) {
    return x < y;
  } else {
    return x < immediate_operand;
  }
}



int simple_raw_2_2_stateful_alu_0_0_Opt_0(int op1, int enable) {
    if (enable != 0) return 0;
    return op1;
    }

int simple_raw_2_2_stateful_alu_0_0_C_0(int const) {
    return const;
    }

int simple_raw_2_2_stateful_alu_0_0_Mux2_0(int op1, int op2, int choice) {
    if (choice == 0) return op1;
    else return op2;
    }

int simple_raw_2_2_stateful_alu_0_0(ref int state_1, int pkt_1, int Mux2_0,int Opt_0,int const_0) {
 int old_state = state_1;state_1 = simple_raw_2_2_stateful_alu_0_0_Opt_0(state_1,Opt_0)+simple_raw_2_2_stateful_alu_0_0_Mux2_0(pkt_1,simple_raw_2_2_stateful_alu_0_0_C_0(const_0),Mux2_0);
; return old_state;
}
int simple_raw_2_2_stateless_alu_1_0_mux1(int input0,int input1, int simple_raw_2_2_stateless_alu_1_0_mux1_ctrl_local) {

  int mux_ctrl = simple_raw_2_2_stateless_alu_1_0_mux1_ctrl_local;
  if (mux_ctrl == 0) {
    return input0;
  }


  else { return input1; }

}int simple_raw_2_2_stateless_alu_1_0_mux2(int input0,int input1, int simple_raw_2_2_stateless_alu_1_0_mux2_ctrl_local) {

  int mux_ctrl = simple_raw_2_2_stateless_alu_1_0_mux2_ctrl_local;
  if (mux_ctrl == 0) {
    return input0;
  }


  else { return input1; }

}int simple_raw_2_2_stateless_alu_1_0(int input0,int input1, int opcode_hole_local, int immediate_operand_hole_local, int mux1_ctrl_hole_local, int mux2_ctrl_hole_local) {
  int opcode = opcode_hole_local;
  int immediate_operand = immediate_operand_hole_local;

  int x = simple_raw_2_2_stateless_alu_1_0_mux1(input0,input1, mux1_ctrl_hole_local);
  int y = simple_raw_2_2_stateless_alu_1_0_mux2(input0,input1, mux2_ctrl_hole_local);

  if (opcode == 0) {
    return immediate_operand;
  } else if (opcode == 1) {
    return x + y;
  } else if (opcode == 2) {
    return x + immediate_operand;
  } else if (opcode == 3) {
    return x - y;
  } else if (opcode == 4) {
    return x - immediate_operand;
  } else if (opcode == 5) {
    return immediate_operand - x;
  } else if (opcode == 6) {
    return (x != 0) || (y != 0);
  } else if (opcode == 7) {
    return (x != 0) || (immediate_operand != 0);
  } else if (opcode == 8) {
    return (x != 0) && (y != 0);
  } else if (opcode == 9) {
    return (x != 0) && (immediate_operand != 0);
  } else if (opcode == 10) {
    return ! (x != 0);
  } else if (opcode == 11) {
    return x != y;
  } else if (opcode == 12) {
    return x != immediate_operand;
  } else if (opcode == 13) {
    return x == y;
  } else if (opcode == 14) {
    return x == immediate_operand;
  } else if (opcode == 15) {
    return x >= y;
  } else if (opcode == 16) {
    return x >= immediate_operand;
  } else if (opcode == 17) {
    return x < y;
  } else {
    return x < immediate_operand;
  }
}
int simple_raw_2_2_stateless_alu_1_1_mux1(int input0,int input1, int simple_raw_2_2_stateless_alu_1_1_mux1_ctrl_local) {

  int mux_ctrl = simple_raw_2_2_stateless_alu_1_1_mux1_ctrl_local;
  if (mux_ctrl == 0) {
    return input0;
  }


  else { return input1; }

}int simple_raw_2_2_stateless_alu_1_1_mux2(int input0,int input1, int simple_raw_2_2_stateless_alu_1_1_mux2_ctrl_local) {

  int mux_ctrl = simple_raw_2_2_stateless_alu_1_1_mux2_ctrl_local;
  if (mux_ctrl == 0) {
    return input0;
  }


  else { return input1; }

}int simple_raw_2_2_stateless_alu_1_1(int input0,int input1, int opcode_hole_local, int immediate_operand_hole_local, int mux1_ctrl_hole_local, int mux2_ctrl_hole_local) {
  int opcode = opcode_hole_local;
  int immediate_operand = immediate_operand_hole_local;

  int x = simple_raw_2_2_stateless_alu_1_1_mux1(input0,input1, mux1_ctrl_hole_local);
  int y = simple_raw_2_2_stateless_alu_1_1_mux2(input0,input1, mux2_ctrl_hole_local);

  if (opcode == 0) {
    return immediate_operand;
  } else if (opcode == 1) {
    return x + y;
  } else if (opcode == 2) {
    return x + immediate_operand;
  } else if (opcode == 3) {
    return x - y;
  } else if (opcode == 4) {
    return x - immediate_operand;
  } else if (opcode == 5) {
    return immediate_operand - x;
  } else if (opcode == 6) {
    return (x != 0) || (y != 0);
  } else if (opcode == 7) {
    return (x != 0) || (immediate_operand != 0);
  } else if (opcode == 8) {
    return (x != 0) && (y != 0);
  } else if (opcode == 9) {
    return (x != 0) && (immediate_operand != 0);
  } else if (opcode == 10) {
    return ! (x != 0);
  } else if (opcode == 11) {
    return x != y;
  } else if (opcode == 12) {
    return x != immediate_operand;
  } else if (opcode == 13) {
    return x == y;
  } else if (opcode == 14) {
    return x == immediate_operand;
  } else if (opcode == 15) {
    return x >= y;
  } else if (opcode == 16) {
    return x >= immediate_operand;
  } else if (opcode == 17) {
    return x < y;
  } else {
    return x < immediate_operand;
  }
}



int simple_raw_2_2_stateful_alu_1_0_Opt_0(int op1, int enable) {
    if (enable != 0) return 0;
    return op1;
    }

int simple_raw_2_2_stateful_alu_1_0_C_0(int const) {
    return const;
    }

int simple_raw_2_2_stateful_alu_1_0_Mux2_0(int op1, int op2, int choice) {
    if (choice == 0) return op1;
    else return op2;
    }

int simple_raw_2_2_stateful_alu_1_0(ref int state_1, int pkt_1, int Mux2_0,int Opt_0,int const_0) {
 int old_state = state_1;state_1 = simple_raw_2_2_stateful_alu_1_0_Opt_0(state_1,Opt_0)+simple_raw_2_2_stateful_alu_1_0_Mux2_0(pkt_1,simple_raw_2_2_stateful_alu_1_0_C_0(const_0),Mux2_0);
; return old_state;
}


// Data type for holding result from spec and implementation
struct StateAndPacket {

    int pkt_0;


    int state_0;

}

// Specification
// Spec for Sketch
|StateAndPacket| program (|StateAndPacket| state_and_packet) {
  state_and_packet.pkt_0 = 1 + state_and_packet.state_0;
  return state_and_packet;
}


// Implementation

|StateAndPacket| pipeline (|StateAndPacket| state_and_packet) {
// Consolidate all constraints on holes here.
assert((simple_raw_2_2_stateless_alu_0_0_opcode == 1)|| (simple_raw_2_2_stateless_alu_0_0_mux1_ctrl <= simple_raw_2_2_stateless_alu_0_0_mux2_ctrl));
assert((simple_raw_2_2_stateless_alu_0_1_opcode == 1)|| (simple_raw_2_2_stateless_alu_0_1_mux1_ctrl <= simple_raw_2_2_stateless_alu_0_1_mux2_ctrl));
assert((simple_raw_2_2_stateless_alu_1_0_opcode == 1)|| (simple_raw_2_2_stateless_alu_1_0_mux1_ctrl <= simple_raw_2_2_stateless_alu_1_0_mux2_ctrl));
assert((simple_raw_2_2_stateless_alu_1_1_opcode == 1)|| (simple_raw_2_2_stateless_alu_1_1_mux1_ctrl <= simple_raw_2_2_stateless_alu_1_1_mux2_ctrl));
assert((simple_raw_2_2_salu_config_0_0 + 0) <= 2);
assert((simple_raw_2_2_salu_config_1_0 + 0) <= 2);
assert((simple_raw_2_2_salu_config_0_0 + simple_raw_2_2_salu_config_1_0 + 0) <= 1);


  // One variable for each container in the PHV
  // Container i will be allocated to packet field i from the spec.

    int input_0_0 = 0;

    int input_0_1 = 0;


  // One variable for each stateful ALU's state operand
  // This will be allocated to a state variable from the program using indicator variables.


    int state_operand_salu_0_0;



    int state_operand_salu_1_0;




  /*********** Stage 0 *********/

  // Inputs

  // Read each PHV container from corresponding packet field.

  input_0_0 = state_and_packet.pkt_0;




  // Stateless ALUs

  int destination_0_0 = simple_raw_2_2_stateless_alu_0_0(


  input_0_0,



  input_0_1

  ,
  simple_raw_2_2_stateless_alu_0_0_opcode,
  simple_raw_2_2_stateless_alu_0_0_immediate,
  simple_raw_2_2_stateless_alu_0_0_mux1_ctrl,
  simple_raw_2_2_stateless_alu_0_0_mux2_ctrl
  );

  int destination_0_1 = simple_raw_2_2_stateless_alu_0_1(


  input_0_0,



  input_0_1

  ,
  simple_raw_2_2_stateless_alu_0_1_opcode,
  simple_raw_2_2_stateless_alu_0_1_immediate,
  simple_raw_2_2_stateless_alu_0_1_mux1_ctrl,
  simple_raw_2_2_stateless_alu_0_1_mux2_ctrl
  );


  // Stateful operands


  int packet_operand_salu0_0_0 = simple_raw_2_2_stateful_operand_mux_0_0_0(


  input_0_0,



  input_0_1


  , simple_raw_2_2_stateful_operand_mux_0_0_0_ctrl);



  // Read stateful ALU slots from allocated state vars.


  if (simple_raw_2_2_salu_config_0_0 == 1) { state_operand_salu_0_0 = state_and_packet.state_0;}



  // Stateful ALUs

  int old_state_0_0 = simple_raw_2_2_stateful_alu_0_0(state_operand_salu_0_0,

  packet_operand_salu0_0_0,


  simple_raw_2_2_stateful_alu_0_0_Mux2_0_global,simple_raw_2_2_stateful_alu_0_0_Opt_0_global,simple_raw_2_2_stateful_alu_0_0_const_0_global);


  // Outputs

  int output_0_0 = simple_raw_2_2_output_mux_phv_0_0(

  old_state_0_0,

  destination_0_0,
  simple_raw_2_2_output_mux_phv_0_0_ctrl
  );

  int output_0_1 = simple_raw_2_2_output_mux_phv_0_1(

  old_state_0_0,

  destination_0_1,
  simple_raw_2_2_output_mux_phv_0_1_ctrl
  );



  // Write state_0

  if (simple_raw_2_2_salu_config_0_0 == 1) { state_and_packet.state_0 = state_operand_salu_0_0;}




  /*********** Stage 1 *********/

  // Inputs

  // Input of this stage is the output of the previous one.

  int input_1_0 = output_0_0;

  int input_1_1 = output_0_1;




  // Stateless ALUs

  int destination_1_0 = simple_raw_2_2_stateless_alu_1_0(


  input_1_0,



  input_1_1

  ,
  simple_raw_2_2_stateless_alu_1_0_opcode,
  simple_raw_2_2_stateless_alu_1_0_immediate,
  simple_raw_2_2_stateless_alu_1_0_mux1_ctrl,
  simple_raw_2_2_stateless_alu_1_0_mux2_ctrl
  );

  int destination_1_1 = simple_raw_2_2_stateless_alu_1_1(


  input_1_0,



  input_1_1

  ,
  simple_raw_2_2_stateless_alu_1_1_opcode,
  simple_raw_2_2_stateless_alu_1_1_immediate,
  simple_raw_2_2_stateless_alu_1_1_mux1_ctrl,
  simple_raw_2_2_stateless_alu_1_1_mux2_ctrl
  );


  // Stateful operands


  int packet_operand_salu1_0_0 = simple_raw_2_2_stateful_operand_mux_1_0_0(


  input_1_0,



  input_1_1


  , simple_raw_2_2_stateful_operand_mux_1_0_0_ctrl);



  // Read stateful ALU slots from allocated state vars.


  if (simple_raw_2_2_salu_config_1_0 == 1) { state_operand_salu_1_0 = state_and_packet.state_0;}



  // Stateful ALUs

  int old_state_1_0 = simple_raw_2_2_stateful_alu_1_0(state_operand_salu_1_0,

  packet_operand_salu1_0_0,


  simple_raw_2_2_stateful_alu_1_0_Mux2_0_global,simple_raw_2_2_stateful_alu_1_0_Opt_0_global,simple_raw_2_2_stateful_alu_1_0_const_0_global);


  // Outputs

  int output_1_0 = simple_raw_2_2_output_mux_phv_1_0(

  old_state_1_0,

  destination_1_0,
  simple_raw_2_2_output_mux_phv_1_0_ctrl
  );

  int output_1_1 = simple_raw_2_2_output_mux_phv_1_1(

  old_state_1_0,

  destination_1_1,
  simple_raw_2_2_output_mux_phv_1_1_ctrl
  );



  // Write state_0

  if (simple_raw_2_2_salu_config_1_0 == 1) { state_and_packet.state_0 = state_operand_salu_1_0;}






  // Write pkt_0
  state_and_packet.pkt_0 = output_1_0;


  // Return updated packet fields and state vars
  return state_and_packet;
}


harness void main(
  int pkt_0,
  int state_0) {

  |StateAndPacket| x = |StateAndPacket|(
    pkt_0 = pkt_0,



    state_0 = state_0

  );

assert(pipeline(x) == program(x));
}
