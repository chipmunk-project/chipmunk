import re

import z3


def parse_smt2_file(smt2_filename):
    """Reads a smt2 file and returns the first formula.

    Args:
        smt2_filename: smt2 file that was generated from Sketch.

    Raises:
        An assertion if the original smt2 file didn't contain any assert
        statements.
    """
    # parse_smt2_file returns a vector of ASTs, and each element corresponds to
    # one assert statement in the original file. The smt2 file generated by
    # sketch only has one assertions, simply take the first.
    formulas = z3.parse_smt2_file(smt2_filename)
    assert len(formulas) >= 1, (smt2_filename,
                                "doesn't contain any assert statements.")
    return formulas[0]


def generate_counter_examples(smt2_filename):
    """Given a smt2 file that was generated from sketch, returns counterexample
    values for input packet fields and state group variables.

    Returns:
        A tuple of two dicts from string to ints, where the first one
        represents counterexamples for packet variables and the second for
        state group variables.
    """
    formula = parse_smt2_file(smt2_filename)

    # The formula is of form Forall(variables, Implies(A, B)). If the formula
    # is unsatisfiable we want to get the value of counterexample. To do so, we
    # need to negate the Implies part of the formula and strip off Forall. If
    # we simply take the Implies part, it will contain free variables intead of
    # named variables. We need to get the list of variables in the order they
    # appear in the Implies part and substitute them.
    var_names = [formula.var_name(i) for i in range(formula.num_vars())]
    f_str = str(formula)
    implies_str = f_str[f_str.index("Implies"):]
    var_names.sort(key=lambda c: implies_str.index(c))

    # Now declare variables and new formula only containing Implies part.
    variables = [z3.Int(n) for n in var_names]
    new_formula = z3.Not(z3.substitute_vars(formula.body(), *variables))

    z3_slv = z3.Solver()
    z3_slv.set(proof=True, unsat_core=True)
    z3_slv.add(new_formula)

    pkt_vars = {}
    state_vars = {}

    result = z3_slv.check()
    if result != z3.sat:
        print("Failed to generate counterexamples, z3 returned", result)
        return (pkt_vars, state_vars)

    model = z3_slv.model()
    for var in variables:
        # The variable names used by sketch have trailing _\d+_\d+_\d+ pattern,
        # need to remove them to get original variable names.
        var_str = re.sub(r"_\d+_\d+_\d+$", "", str(var), count=1)
        value = model.eval(var).as_long()
        if var_str.startswith("pkt_"):
            pkt_vars[var_str] = value
        elif var_str.startswith("state_group_"):
            state_vars[var_str] = value

    return (pkt_vars, state_vars)


def check_without_bnds(smt2_filename):
    """Given a smt2 file generated from a sketch, parses assertion from the
    file and checks whether it holds for all integers representable in z3.

    Returns:
        True if satisfiable else False.
    """
    formula = parse_smt2_file(smt2_filename)
    print(formula)

    # The original formula's body is comprised of Implies(A, B) where A
    # specifies range of input variables and where B is a condition that we're
    # interested to check. We only want to get the B.
    body = formula.body().children()[1]

    variables = [z3.Int(formula.var_name(i))
                 for i in range(formula.num_vars())]
    formula_without_bounds = z3.ForAll(variables, body)
    print(formula_without_bounds)

    z3_slv = z3.Solver()
    z3_slv.add(formula_without_bounds)

    return z3_slv.check() == z3.sat
